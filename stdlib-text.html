<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="img/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="img/icon.ico">
  <title>Standard Library - text</title>
  <meta name="title" content="Standard Library - text" />
  <meta name="description" content="the vv language" />
  <meta name="keywords" content="vv" />

  <link rel="stylesheet" href="css/theme.css">
  <link rel="stylesheet" href="css/highlight.css">
  <link rel="stylesheet" href="css/site.css">
  <link rel="stylesheet" href="css/board.css">
  <script src="js/highlight.js"></script>
  <script src="js/live.js"></script>
  <script src="js/umbrella.js"></script>

</head>

<body>
<nav>
  <a id="brand" href="./">VV</a>
  <a href="./release.html">RELEASE</a>
  <a href="https://github.com/malivvan/vv">SOURCE</a>
</nav>
<header>
  <h1>Standard Library - text</h1>
</header>
<article><h2 id="import">Import <a class="anchor" href="#import"> </a></h2>
<pre><code class="language-golang">text := import(&quot;text&quot;)
</code></pre>
<h2 id="functions">Functions <a class="anchor" href="#functions"> </a></h2>
<ul>
<li><code>re_match(pattern string, text string) =&gt; bool/error</code>: reports whether the
string s contains any match of the regular expression pattern.</li>
<li><code>re_find(pattern string, text string, count int) =&gt; [[{text: string, begin: int, end: int}]]/undefined</code>:
returns an array holding all matches, each of which is an array of map object
that contains matching text, begin and end (exclusive) index.</li>
<li><code>re_replace(pattern string, text string, repl string) =&gt; string/error</code>:
returns a copy of src, replacing matches of the pattern with the replacement
string repl.</li>
<li><code>re_split(pattern string, text string, count int) =&gt; [string]/error</code>: slices
s into substrings separated by the expression and returns a slice of the
substrings between those expression matches.</li>
<li><code>re_compile(pattern string) =&gt; Regexp/error</code>: parses a regular expression and
returns, if successful, a Regexp object that can be used to match against
text.</li>
<li><code>compare(a string, b string) =&gt; int</code>: returns an integer comparing two
strings lexicographically. The result will be 0 if a==b, -1 if a &lt; b, and +1
if a &gt; b.</li>
<li><code>contains(s string, substr string) =&gt; bool</code>: reports whether substr is within
s.</li>
<li><code>contains_any(s string, chars string) =&gt; bool</code>: reports whether any Unicode
code points in chars are within s.</li>
<li><code>count(s string, substr string) =&gt; int</code>: counts the number of non-overlapping
instances of substr in s.</li>
<li><code>equal_fold(s string, t string) =&gt; bool</code>: reports whether s and t,
interpreted as UTF-8 strings,</li>
<li><code>fields(s string) =&gt; [string]</code>: splits the string s around each instance of
one or more consecutive white space characters, as defined by unicode.IsSpace,
returning a slice of substrings of s or an empty slice if s contains only
white space.</li>
<li><code>has_prefix(s string, prefix string) =&gt; bool</code>: tests whether the string s
begins with prefix.</li>
<li><code>has_suffix(s string, suffix string) =&gt; bool</code>: tests whether the string s
ends with suffix.</li>
<li><code>index(s string, substr string) =&gt; int</code>: returns the index of the first
instance of substr in s, or -1 if substr is not present in s.</li>
<li><code>index_any(s string, chars string) =&gt; int</code>: returns the index of the first
instance of any Unicode code point from chars in s, or -1 if no Unicode code
point from chars is present in s.</li>
<li><code>join(arr string, sep string) =&gt; string</code>: concatenates the elements of a to
create a single string. The separator string sep is placed between elements
in the resulting string.</li>
<li><code>last_index(s string, substr string) =&gt; int</code>: returns the index of the last
instance of substr in s, or -1 if substr is not present in s.</li>
<li><code>last_index_any(s string, chars string) =&gt; int</code>: returns the index of the
last instance of any Unicode code point from chars in s, or -1 if no Unicode
code point from chars is present in s.</li>
<li><code>repeat(s string, count int) =&gt; string</code>: returns a new string consisting of
count copies of the string s.</li>
<li><code>replace(s string, old string, new string, n int) =&gt; string</code>: returns a copy
of the string s with the first n non-overlapping instances of old replaced by
new.</li>
<li><code>substr(s string, lower int, upper int) =&gt; string =&gt; string</code>: returns a
substring of the string s specified by the lower and upper parameters.</li>
<li><code>split(s string, sep string) =&gt; [string]</code>: slices s into all substrings
separated by sep and returns a slice of the substrings between those
separators.</li>
<li><code>split_after(s string, sep string) =&gt; [string]</code>: slices s into all substrings
after each instance of sep and returns a slice of those substrings.</li>
<li><code>split_after_n(s string, sep string, n int) =&gt; [string]</code>: slices s into
substrings after each instance of sep and returns a slice of those substrings.</li>
<li><code>split_n(s string, sep string, n int) =&gt; [string]</code>: slices s into substrings
separated by sep and returns a slice of the substrings between those
separators.</li>
<li><code>title(s string) =&gt; string</code>: returns a copy of the string s with all Unicode
letters that begin words mapped to their title case.</li>
<li><code>to_lower(s string) =&gt; string</code>: returns a copy of the string s with all
Unicode letters mapped to their lower case.</li>
<li><code>to_title(s string) =&gt; string</code>: returns a copy of the string s with all
Unicode letters mapped to their title case.</li>
<li><code>to_upper(s string) =&gt; string</code>: returns a copy of the string s with all
Unicode letters mapped to their upper case.</li>
<li><code>pad_left(s string, pad_len int, pad_with string) =&gt; string</code>: returns a copy
of the string s padded on the left with the contents of the string pad_with
to length pad_len. If pad_with is not specified, white space is used as the
default padding.</li>
<li><code>pad_right(s string, pad_len int, pad_with string) =&gt; string</code>: returns a
copy of the string s padded on the right with the contents of the string
pad_with to length pad_len. If pad_with is not specified, white space is
used as the default padding.</li>
<li><code>trim(s string, cutset string) =&gt; string</code>: returns a slice of the string s
with all leading and trailing Unicode code points contained in cutset removed.</li>
<li><code>trim_left(s string, cutset string) =&gt; string</code>: returns a slice of the string
s with all leading Unicode code points contained in cutset removed.</li>
<li><code>trim_prefix(s string, prefix string) =&gt; string</code>: returns s without the
provided leading prefix string.</li>
<li><code>trim_right(s string, cutset string) =&gt; string</code>: returns a slice of the
string s, with all trailing Unicode code points contained in cutset removed.</li>
<li><code>trim_space(s string) =&gt; string</code>: returns a slice of the string s, with all
leading and trailing white space removed, as defined by Unicode.</li>
<li><code>trim_suffix(s string, suffix string) =&gt; string</code>: returns s without the
provided trailing suffix string.</li>
<li><code>atoi(str string) =&gt; int/error</code>: returns the result of ParseInt(s, 10, 0)
converted to type int.</li>
<li><code>format_bool(b bool) =&gt; string</code>: returns &ldquo;true&rdquo; or &ldquo;false&rdquo; according to the
value of b.</li>
<li><code>format_float(f float, fmt string, prec int, bits int) =&gt; string</code>: converts
the floating-point number f to a string, according to the format fmt and
precision prec.</li>
<li><code>format_int(i int, base int) =&gt; string</code>: returns the string representation of
i in the given base, for 2 &lt;= base &lt;= 36. The result uses the lower-case
letters &lsquo;a&rsquo; to &lsquo;z&rsquo; for digit values &gt;= 10.</li>
<li><code>itoa(i int) =&gt; string</code>: is shorthand for format_int(i, 10).</li>
<li><code>parse_bool(s string) =&gt; bool/error</code>: returns the boolean value represented
by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false,
False. Any other value returns an error.</li>
<li><code>parse_float(s string, bits int) =&gt; float/error</code>: converts the string s to a
floating-point number with the precision specified by bitSize: 32 for float32,
or 64 for float64. When bitSize=32, the result still has type float64, but it
will be convertible to float32 without changing its value.</li>
<li><code>parse_int(s string, base int, bits int) =&gt; int/error</code>: interprets a string s
in the given base (0, 2 to 36) and bit size (0 to 64) and returns the
corresponding value i.</li>
<li><code>quote(s string) =&gt; string</code>: returns a double-quoted Go string literal
representing s. The returned string uses Go escape sequences (\t, \n, \xFF,
\u0100) for control characters and non-printable characters as defined by
IsPrint.</li>
<li><code>unquote(s string) =&gt; string/error</code>: interprets s as a single-quoted,
double-quoted, or backquoted Go string literal, returning the string value
that s quotes.  (If s is single-quoted, it would be a Go character literal;
Unquote returns the corresponding one-character string.)</li>
</ul>
<h2 id="regexp">Regexp <a class="anchor" href="#regexp"> </a></h2>
<ul>
<li><code>match(text string) =&gt; bool</code>: reports whether the string s contains any match
of the regular expression pattern.</li>
<li><code>find(text string, count int) =&gt; [[{text: string, begin: int, end: int}]]/undefined</code>:
returns an array holding all matches, each of which is an array of map object
that contains matching text, begin and end (exclusive) index.</li>
<li><code>replace(src string, repl string) =&gt; string</code>: returns a copy of src,
replacing matches of the pattern with the replacement string repl.</li>
<li><code>split(text string, count int) =&gt; [string]</code>: slices s into substrings
separated by the expression and returns a slice of the substrings between
those expression matches.</li>
</ul>
</article>
<footer>
  <div style="float: left;">Copyright &copy; malivvan</div>
  <div style="float: right;">Last modified <time datetime="2025-08-03T20:53:46Z+00:00
">Sun Aug  3 20:53:46 UTC 2025
</time></div>
</footer>
<script>
  hljs.highlightAll();
</script>
</body>

</html>